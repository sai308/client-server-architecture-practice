# Тести для `services`

Ця папка містить модульні тести для сервісного шару додатка, зокрема, націлені на основні функціональні можливості `AuthService`, `CheckoutService`, `JwtService` та `PricingService`. Кожен сервіс має власний файл тестів з модульними, ізольованими тестовими кейсами для забезпечення високої точності та підтримки.

---

## Зміст

1. [Вступ до Модульного Тестування](#вступ-до-модульного-тестування)
2. [Принципи Модульного Тестування](#принципи-модульного-тестування)
3. [Структура Тестування Сервісів](#структура-тестування-сервісів)
4. [Запуск Тестів](#запуск-тестів)
5. [Детальне Пояснення Тестів](#детальне-пояснення-тестів)

---

## Вступ до модульного тестування

Модульне тестування — це фундаментальна практика розробки програмного забезпечення, яка зосереджується на перевірці найменших частин додатка, зазвичай окремих функцій чи методів, в ізоляції від решти системи. Створюючи тести на такому детальному рівні, ми можемо впевнено переконатися, що кожен компонент поводиться відповідно до очікувань у різних умовах.

У архітектурі цього проєкту **сервіси** містять основну бізнес-логіку, що робить їх критично важливими кандидатами для модульного тестування. Тестування цих сервісів допомагає переконатися, що логіка працює правильно, обробляє помилки та взаємодіє з залежностями, як очікується.

---

## Принципи модульного тестування

Перед тим як перейти до реалізації, розглянемо кілька основних принципів модульного тестування:

1. **Ізоляція**: Кожен модульний тест повинен перевіряти одну функцію або метод в ізоляції, без залежностей від інших частин додатка. Для симуляції поведінки зовнішніх компонентів або сервісів часто використовуються моки чи заглушки.

2. **Повторюваність**: Тести повинні давати однаковий результат кожного разу, коли вони запускаються. Вони не повинні залежати від будь-якого зовнішнього стану або даних, які можуть змінюватися між запусками тестів.

3. **Простота**: Модульні тести повинні бути простими й зосереджуватися на перевірці однієї поведінки. Складні тести, що перевіряють кілька поведінок, можуть бути важкими для підтримки та налагодження.

4. **Швидке виконання**: Оскільки модульні тести перевіряють лише невеликі частини додатка, вони повинні виконуватися швидко. Це робить їх придатними для частого запуску під час розробки для вчасного виявлення проблем.

5. **Чітка назва та структура**: Кожен тест повинен мати описову назву, яка чітко вказує, що саме перевіряється та який очікуваний результат. Це допомагає в розумінні та підтримці набору тестів.

---

## Структура Тестування Сервісів

Кожен сервіс тестується незалежно для перевірки його основної функціональності. Ось огляд структури, яка використовується в кожному файлі тесту:

### 1. **Тести для AuthService**

- Тести розташовані в `authService.test.js`.
- **Мета**: Перевірка основних функцій аутентифікації, таких як хешування пароля, перевірка користувача та генерація токенів.
- **Основні тестові кейси**:
  - Хешування пароля, щоб забезпечити, що згенеровані хеші не збігаються з оригінальним паролем.
  - Аутентифікація для підтвердження, що користувачі з дійсними обліковими даними правильно ідентифікуються.
  - Генерація токенів для забезпечення того, що токени доступу та оновлення надаються при успішному вході.

### 2. **Тести для CheckoutService**

- Тести розташовані в `checkoutService.test.js`.
- **Мета**: Забезпечення роботи процесу оформлення замовлення, від розрахунку загальної суми до генерації квитанцій.
- **Основні тестові кейси**:
  - Перевірка, що квитанція генерується з правильним ідентифікатором користувача, загальною сумою та списком товарів.
  - Перевірка очищення кошика після успішного оформлення замовлення.

### 3. **Тести для JwtService**

- Тести розташовані в `jwtService.test.js`.
- **Мета**: Перевірка генерації та верифікації токенів доступу та оновлення.
- **Основні тестові кейси**:
  - Переконання, що дійсні токени доступу та оновлення згенеровані та можуть бути верифіковані.
  - Перевірка, що недійсні токени повертають `null`, щоб уникнути несанкціонованого доступу.

### 4. **Тести для PricingService**

- Тести розташовані в `pricingService.test.js`.
- **Мета**: Перевірка правильності обчислень для загальних сум товарів та кошика.
- **Основні тестові кейси**:
  - Обчислення загальної суми кошика з урахуванням знижок та податку для забезпечення точності кінцевої суми.
  - Обчислення загальної суми окремих товарів на основі ціни та кількості.

---

## Запуск тестів

Щоб запустити всі тести в папці `tests/services`, використовуйте наступну команду:

```bash
node --test ./tests/services/**/*.test.js
```

Або, якщо використовується тестовий скрипт у `package.json`, можна запустити:

```bash
pnpm test
```

Це виконає кожен файл тесту, надаючи інформацію про результати кожного модульного тесту.

---

## Детальне пояснення тестів

Кожен тест створений відповідно до принципів модульного тестування. Розглянемо, як ми застосовуємо ці принципи на практиці:

### Ізоляція за допомогою "моків"

Для залежностей, від яких залежить сервіс (наприклад, `UserRepository`, `CartRepository`), ми використовуємо **мок-об'єкти**. Мокування дозволяє симулювати, як залежності повинні поводитися, без потреби в доступі до реальних екземплярів, що може призвести до побічних ефектів або помилок через зовнішні умови.

Приклад:

```javascript
const mockUserRepository = {
  getByUsername: async (username) => {
    if (username === 'testuser') {
      return {
        id: '1',
        username,
        passwordHash: await bcrypt.hash('password', 10),
      };
    }
    return null;
  },
};
```

Ця мок-функція `getByUsername` повертає симульований об'єкт користувача для певного імені користувача, що дозволяє нам тестувати функціональність `AuthService` без потреби в доступі до фактичної бази даних.

### Чітка назва та структура

Кожна тестова функція дотримується угоди про найменування, яка чітко вказує на перевірювану функцію та очікуваний результат. Наприклад:

```javascript
it('🔒 should generate a hashed password that does not match the original', async () => {
  // Логіка тесту
});
```

Ця назва пояснює, що ми перевіряємо функцію хешування в `AuthService` і що отриманий хеш не повинен збігатися з оригінальним паролем.

### Простота та повторюваність

Кожен тест простий і зосереджений на одній перевірці. Це полегшує виявлення частини функціональності, яка не працює, якщо тест не пройде.

Приклад:

```javascript
it('🛒 should generate a receipt and clear the cart upon checkout', async () => {
  const userId = '1';
  const receipt = await checkoutService.checkout(userId);
  assert.strictEqual(
    receipt.userId,
    userId,
    'Receipt userId should match provided userId'
  );
  assert.ok(receipt.totalAmount, 'Receipt should have a total amount');
  assert.ok(receipt.items.length > 0, 'Receipt should have items');
});
```

У цьому прикладі:

- Ми перевіряємо лише генерацію квитанції та очищення кошика для функції оформлення замовлення.
- Кожна перевірка має конкретне призначення, що дозволяє перевірити, чи кожен елемент (наприклад, `userId`, `totalAmount`) поводиться як очікується.

### Швидке виконання

Оскільки кожен тестовий кейс ізольований і перевіряє лише поведінку невеликих функцій або методів, вони виконуються швидко. Це робить набір тестів придатним для частих запусків під час розробки, надаючи ранній зворотний зв'язок про потенційні проблеми.

### Використання синтаксису `describe` та `it`

Структура `describe` та `it` групує пов'язані тести, що полегшує розуміння обсягу та мети кожної групи тестів.

Приклад:

```javascript
describe('AuthService', () => {
  it('🔒 should generate a hashed password that does not match the original', async () => {
    // Логіка тесту
  });

  it('✅ should return user if credentials are correct', async () => {
    // Логіка тесту
  });
});
```

Ця структура показує, що кожен блок `it` — це окремий модульний тест у рамках тестового набору `AuthService`, що покращує зручність читання та організацію.

---

## Підсумок

Папка `tests/services` містить добре організовані модульні тести для кожного сервісу в додатку. Дотримуючись основних принципів модульного тестування, ці тести:

- Ізолюють функціональності за допомогою моків і симулюють залежності.
- Перевіряють індивідуальні поведінки без залежності від зовнішніх систем.
- Надають чіткий, лаконічний зворотний зв'язок про кожну перевірену функцію.

Ці модульні тести служать базовим інструментом для забезпечення того, що основна бізнес-логіка в сервісах працює відповідно до очікувань, що в підсумку допомагає підтримувати цілісність додатка в процесі його розвитку.
